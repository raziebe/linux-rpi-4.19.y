#include <linux/module.h>
#include <linux/highmem.h>
#include <linux/hyplet.h>
#include <linux/delay.h>
#include <linux/proc_fs.h>
#include "hyp_mmu.h"
#include "hypletS.h"


struct stage2_fault_addr {
	unsigned long phys_addr;
	unsigned long *stg2_desc_pg;
	int stg2_desc_idx;
	int fault_mmio_to_el2;
};

static struct stage2_fault_addr faddr;

#if defined(RASPBERRY_PI3)
	#define EL2_FAULT_ADDRESS  0x3f980000LL
#else
#define EL2_FAULT_ADDRESS 0x1a000000LL
#endif

static long el2_fault_address(void)
{
	return EL2_FAULT_ADDRESS;
}

/*
 * Called in EL2 to handle a faulted address
 */
int __hyp_text hyplet_handle_abrt(struct hyplet_vm *vm, unsigned long addr)
{
	if (!( addr >= el2_fault_address() &&
		addr <= (el2_fault_address() + PAGE_SIZE) ) ){
			return 0;
	}

	/*
	 * An access to the virtual device detected.
	 * record the user and count
	 */
	 vm->dev_access.last_current = (unsigned long)current;
	 vm->dev_access.count++;
	 return 1;
}

static long make_special_page_desc(unsigned long real_phyaddr,int s2_rw)
{
	unsigned long addr = real_phyaddr;
	/*
	 *  //l3_descriptor[i] = make_special_page_desc((*addr));
	 * To conceal a device, we put z zero page.
	 * return (long) page_to_phys(ZERO_PAGE(0))
	* In cases where we want to monitor access to a device.
	* we return the same address but change the access permissions
	*/
	return (DESC_AF) | (0b11 << DESC_SHREABILITY_SHIFT) |
	                ( s2_rw  << DESC_S2AP_SHIFT) | (0b1111 << 2) |
	                  DESC_TABLE_BIT | DESC_VALID_BIT | addr;
}

void stash_descriptor(unsigned long phys_addr,unsigned long* pg ,int idx)
{
	if (phys_addr  != el2_fault_address())
			return;
	faddr.phys_addr  = phys_addr;
	faddr.stg2_desc_pg = pg;
	faddr.stg2_desc_idx = idx;
	faddr.fault_mmio_to_el2 = 0;
}

/* user interface  */
static struct proc_dir_entry *procfs = NULL;

static ssize_t proc_write(struct file *file, const char __user * buffer,
			  size_t count, loff_t * dummy)
{
	if (faddr.stg2_desc_idx >= 0 && faddr.phys_addr
				&& faddr.stg2_desc_pg != NULL) {

		if (faddr.fault_mmio_to_el2 == 1){
				faddr.fault_mmio_to_el2 = 0;
				faddr.stg2_desc_pg[faddr.stg2_desc_idx] =
						make_special_page_desc(faddr.phys_addr,
								S2_PAGE_ACCESS_RW);

		} else {
				faddr.fault_mmio_to_el2 = 1;
				faddr.stg2_desc_pg[faddr.stg2_desc_idx] =
						make_special_page_desc(faddr.phys_addr,S2_PAGE_ACCESS_R);
		}
		return count;
	}
	faddr.fault_mmio_to_el2 = 0;
	return count;
}

static int proc_open(struct inode *inode, struct file *filp)
{
	filp->private_data = (void *)0x01;
	return 0;
}

static ssize_t proc_read(struct file *filp, char __user * page,
			 size_t size, loff_t * off)
{
	ssize_t len = 0;
	struct hyplet_vm *vm = NULL;
	int cpu;

	if ( filp->private_data == 0)
		return 0;

	len += sprintf(page + len, "Stage2: %s %lx Descriptor %p idx=%d\n",
			faddr.fault_mmio_to_el2 == 0 ? "off" : "on",
			faddr.phys_addr,
			faddr.stg2_desc_pg,
			faddr.stg2_desc_idx);

	for_each_possible_cpu(cpu){
		vm = hyplet_get(cpu);
		len += sprintf(page + len, "%d LastCurrent 0x%lx count=%ld\n",
				cpu,
				vm->dev_access.last_current,
				vm->dev_access.count);
	}

	filp->private_data = 0x00;
	return len;
}


static struct file_operations malware_proc_ops = {
	.open = proc_open,
	.read = proc_read,
	.write = proc_write,
};


void malware_init_procfs(void)
{
	procfs =
	    proc_create_data("hyplet_stats", O_RDWR, NULL, &malware_proc_ops, NULL);
}
